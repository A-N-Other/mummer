//------------------------------------------------------------------------------
//   Programmer: Adam M Phillippy, The Institute for Genomic Research
//               Guillaume Marcais, University of Maryland
//         File: postnuc.cc
//         Date: 07 / 16 / 2002
//
//     Revision: 08 / 01 / 2002
//               Added MUM extension functionality
//
//      Purpose: To translate the coordinates referencing the concatenated
//              reference sequences back to the individual sequences and deal
//             with any conflict that may have arisen (i.e. a MUM that spans
//            the boundry between two sequences). Then to extend each cluster
//           via Smith-Waterman techniques to expand the alignment coverage.
//          Alignments which encounter each other will be fused to form one
//         encompasing alignment when appropriate.
//
//        Input: Input is the output of the .mgaps program from stdin. On the
//              command line, the file names of the two original sequence files
//             should come first, followed by the prefix <pfx> that should be
//            placed in front of the two output filenames <pfx>.cluster and
//           <pfx>.delta
//
// NOTE: Cluster file is now suppressed by default (see -d option).
//
//       Output: Output is to two output files, <pfx>.cluster and <pfx>.delta.
//              <pfx>.cluster lists MUM clusters as identified by "mgaps".
//             However, the clusters now reference their corresponding
//            sequence and are all listed under headers that specify this
//           sequence. The <pfx>.delta file is the alignment object that
//          contains all the information necessary to reproduce the alignments
//         generated by the MUM extension process. Please refer to the
//        output file documentation for an in-depth description of these
//       file formats.
//
//        Usage: postnuc  <reference>  <query>  <pfx>  <  <input>
//           Where <reference> and <query> are the original input sequences of
//          NUCmer and <pfx> is the prefix that should be added to the
//         beginning of the <pfx>.cluster and <pfx>.delta output filenames.
//
//------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "postnuc.hh"
#include "tigrinc.hh"
#include "sw_align.hh"

using namespace std;
using namespace mummer::postnuc;

//------------------------------------------------------ Globals -------------//
bool DO_DELTA   = true;
bool DO_EXTEND  = true;
bool TO_SEQEND  = false;
bool DO_SHADOWS = false;

void printHelp
(const char * s)

//  Display the program's help information to stderr.

{
  cerr << "\nUSAGE: " << s << " [options]  <reference>  <query>  <pfx>  <  <input>\n\n"
       << "-b int  set the alignment break (give-up) length to int\n"
       << "-B int  set the diagonal banding for extension to int\n"
       << "-d      output only match clusters rather than extended alignments\n"
       <<  "-e      do not extend alignments outward from clusters\n"
       <<  "-h      display help information\n"
       <<  "-s      don't remove shadowed alignments, useful for aligning a\n"
       <<  "        sequence to itself to identify repeats\n"
       <<  "-t      force alignment to ends of sequence if within -b distance\n\n"
       << "  Input is the output of the \"mgaps\" program from stdin, and\n"
       << "the two original NUCmer sequence files passed on the command\n"
       << "line. <pfx> is the prefix to be added to the front of the\n"
       <<  "output file <pfx>.delta\n"
       <<  "  <pfx>.delta is the alignment object that catalogs the distance\n"
       <<  "between insertions and deletions. For further information\n"
       <<  "regarding this file, please refer to the documentation under\n"
       <<  "the .delta output description.\n\n";
}




void printUsage
(const char * s)

//  Display the program's usage information to stderr.

{
  cerr << "\nUSAGE: " << s << " [options]  <reference>  <query>  <pfx>  <  <input>\n\n"
       << "Try '" << s << " -h' for more information.\n";
}

void parse_options(int argc, char* argv[]) {
  optarg = NULL;
  int ch, errflg = 0;
  while ( !errflg  &&  ((ch = getopt (argc, argv, "dehB:b:st")) != EOF) ) {
    switch (ch) {
    case 'b' :
      setBreakLen( atoi (optarg) );
      break;

    case 'B' :
      setBanding( atoi (optarg) );
      break;

    case 'd' :
      DO_DELTA = false;
      break;

    case 'e' :
      DO_EXTEND = false;
      break;

    case 'h' :
      printHelp (argv[0]);
      exit (EXIT_SUCCESS);

    case 's' :
      DO_SHADOWS = true;
      break;

    case 't' :
      TO_SEQEND = true;
      break;

    default :
      errflg ++;
    }
  }
  if ( errflg > 0 || argc - optind != 3 ) {
    printUsage (argv[0]);
    exit (EXIT_FAILURE);
  }
}

int main(int argc, char *argv[]) {
  std::ios::sync_with_stdio(false);

  std::vector<FastaRecord> Af; // array of all the reference sequences

  vector<Synteny>                   Syntenys; // vector of all sets of clusters
  vector<Synteny>::reverse_iterator CurrSp; // current set of clusters
  vector<Synteny>::reverse_iterator Sp; // temporary synteny pointer

  Synteny Asyn;                 // a single set of clusters
  Cluster Aclu;                 // a single cluster of matches
  Match   Amat;                 // a single match

  LineType PrevLine;          // the current input line

  bool Found;                 // temporary search flag

  string Line;                  // a single line of input
  string CurrIdB, IdA, IdB;     // fasta ID headers

  signed char DirB = FORWARD_CHAR;   // the current query strand direction

  long int Seqi;                // current reference sequence index
  long int sA, sB, len;         // current match start in A, B and length

  //-- Set the alignment data type and break length (sw_align.h)
  setMatrixType ( NUCLEOTIDE );
  setBreakLen ( 200 );
  setBanding ( 0 );

  //-- Parse the command line arguments
  parse_options(argc, argv);

  merge_syntenys merger(DO_DELTA, DO_EXTEND, TO_SEQEND, DO_SHADOWS);

  //-- Read and create the I/O file names
  string RefFileName(argv[optind ++]);
  string QryFileName(argv[optind ++]);
  string ClusterFileName(argv[optind ++]);
  string DeltaFileName(ClusterFileName);
  ClusterFileName += ".cluster";
  DeltaFileName   += ".delta";

  //-- Open all the files
  std::ifstream RefFile(RefFileName);
  //  RefFile = File_Open (RefFileName.c_str(), "r");
  std::ifstream QryFile(QryFileName);
  //  QryFile = File_Open (QryFileName.c_str(), "r");
  std::ofstream ClusterFile, DeltaFile;
  if ( DO_DELTA ) {
    open_ofstream(DeltaFile, DeltaFileName);
    DeltaFile << RefFileName << ' ' << QryFileName << "\nNUCMER\n";
  } else {
    open_ofstream(ClusterFile, ClusterFileName);
    ClusterFile << RefFileName << QryFileName << "\nNUCMER\n";
  }

  //-- Generate the array of the reference sequences
  //  InitSize = INIT_SIZE;
  Af.push_back(FastaRecord());
  while(Read_Sequence(RefFile, Af.back()))
    Af.push_back(FastaRecord());
  Af.resize(Af.size() - 1);
  RefFile.close();

  if(Af.empty())
    parseAbort(RefFileName.c_str());

  //-- Process the input from <stdin> line by line
  PrevLine = NO_LINE;
  for(int c = std::cin.peek(); c != EOF; c = std::cin.peek()) {
    if (c == '>' ) { //-- If the current line is a fasta HEADER_LINE
      std::cin.get();
      std::cin >> CurrIdB;
      if(CurrIdB.empty())
        parseAbort(Line + " - " + CurrIdB);
      std::getline(std::cin, Line);
      DirB = Line.find(" Reverse") == string::npos ? FORWARD_CHAR : REVERSE_CHAR;
      PrevLine = HEADER_LINE;
    } else if ( c == '#' ) { //-- If the current line is a cluster HEADER_LINE
      ignore_line(std::cin);
      PrevLine = HEADER_LINE;
    } else { //-- If the current line is a MATCH_LINE
      std::cin >> sA >> sB >> len;
      if(!std::cin.good())
        parseAbort ("stdin" + to_string(cin.tellg()));
      ignore_line(cin); // Ignore rest of line

      //-- Re-map the reference coordinate back to its original sequence
      for ( Seqi = 0; sA > Af[Seqi].len() && (size_t)Seqi < Af.size(); ++Seqi)
        sA -= Af[Seqi].len() + 1; // extra +1 for the x at the end of each seq
      if ((size_t)Seqi >= Af.size()) {
        cerr << "ERROR: A MUM was found with a start coordinate greater than\n"
             << "       the sequence length, a serious error has occured.\n"
             << "       Please file a bug report\n";
        exit (EXIT_FAILURE);
      }

      //-- If the match spans across a sequence boundry
      if ( sA + len - 1 > Af[Seqi].len() || sA <= 0) {
        cerr << "WARNING: A MUM was found extending beyond the boundry of:\n"
             << "         Reference sequence '>" << Af[Seqi].Id() << "'\n\n"
             << "Please check that the '-n' option is activated on 'mummer2'\n"
             << "and try again, or file a bug report\n"
             << "Attempting to continue.\n";
        continue;
      }

      //-- Check and update the current synteny region
      if (IdA != Af[Seqi].Id() || IdB != CurrIdB) {
        Found = false;
        if (IdB == CurrIdB) { //-- Has this header been seen before?
          for ( Sp = Syntenys.rbegin( ); Sp < Syntenys.rend( ); Sp ++ ) {
            if (Sp->AfP->Id() == Af[Seqi].Id()) {
              if ( Sp->AfP->len() != Af[Seqi].len() ) {
                cerr << "ERROR: The reference file may contain"
                     << " sequences with non-unique\n"
                     << "       header Ids, please check your input"
                     << " files and try again\n";
                exit (EXIT_FAILURE);
              }
              assert (Sp->Bf.Id() == IdB);
              CurrSp = Sp;
              Found = true;
              break;
            }
          }
        } else { //-- New B sequence header, process all the old synteny's
          merger.processSyntenys (Syntenys, Af.data(), QryFile, ClusterFile, DeltaFile);
        }

        IdA = Af[Seqi].Id();
        IdB = CurrIdB;

        if ( ! Found ) { //-- If not seen yet, create a new synteny region
          Asyn.AfP    = &Af[Seqi];
          Asyn.Bf.len_w() = -1;
          Asyn.Bf.Id_w()  = IdB;

          Syntenys.push_back (Asyn);
          CurrSp = Syntenys.rbegin( );
        }

        //-- Add a new cluster to the current synteny
        if ( !Syntenys.empty( ) && !CurrSp->clusters.empty( ) )
          if ( CurrSp->clusters.rbegin( )->matches.empty( ) )
            CurrSp->clusters.pop_back( ); // hack to remove empties
        Aclu.wasFused = false;
        Aclu.dirB = DirB;
        CurrSp->clusters.push_back (Aclu);
      } else if ( PrevLine == HEADER_LINE ) { //-- Add a new cluster to the current synteny
        if ( !Syntenys.empty( ) && !CurrSp->clusters.empty( ) )
          if ( CurrSp->clusters.rbegin( )->matches.empty( ) )
            CurrSp->clusters.pop_back( );
        Aclu.wasFused = false;
        Aclu.dirB = DirB;
        CurrSp->clusters.push_back (Aclu);
      }

      if ( len > 1 ) { //-- Add a new match to the current cluster
          Amat.sA = sA;
          Amat.sB = sB;
          Amat.len = len;
          CurrSp->clusters.rbegin( )->matches.push_back (Amat);
      }

      PrevLine = MATCH_LINE;
    }
  }

  //-- Process the left-over syntenys
  if ( !Syntenys.empty( ) && !CurrSp->clusters.empty( ) )
    if ( CurrSp->clusters.rbegin( )->matches.empty( ) )
      CurrSp->clusters.pop_back( );

  merger.processSyntenys(Syntenys, Af.data(), QryFile, ClusterFile, DeltaFile);
  QryFile.close();

  return EXIT_SUCCESS;
}
